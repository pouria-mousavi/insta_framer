import instaloader
import os
import re
import logging
from urllib.parse import urlparse
from config import INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD

import base64

class InstagramService:
    def __init__(self):
        self.loader = instaloader.Instaloader(
            download_pictures=False,
            download_videos=True, 
            download_video_thumbnails=False,
            download_geotags=False,
            download_comments=False,
            save_metadata=False,
            compress_json=False
        )
        self.logged_in = False
        
        # --- Restore Cookies from Env (for Render) ---
        cookies_b64 = os.environ.get('COOKIES_B64')
        if cookies_b64:
            try:
                logging.info("Found COOKIES_B64 env var. Restoring cookies.txt...")
                cookie_data = base64.b64decode(cookies_b64)
                with open("cookies.txt", "wb") as f:
                    f.write(cookie_data)
                logging.info("cookies.txt restored successfully.")
                self.logged_in = True # Assume these cookies are valid to start with
            except Exception as e:
                logging.error(f"Failed to decode COOKIES_B64: {e}")
        # ---------------------------------------------

    def login(self):
        if self.logged_in:
            return True
            
        if not INSTAGRAM_USERNAME:
            print("Instagram username not set.")
            return False
            
        # Try to load session file first (most robust)
        try:
            print(f"Attempting to load session for {INSTAGRAM_USERNAME}...")
            self.loader.load_session_from_file(INSTAGRAM_USERNAME)
            self.logged_in = True
            print(f"Loaded session for {INSTAGRAM_USERNAME}")
            return True
        except FileNotFoundError:
            print("No session file found. Falling back to password login...")
        except Exception as e:
            print(f"Session load error: {e}. Falling back to password login...")
        
        if not INSTAGRAM_PASSWORD:
            print("Instagram password not set.")
            return False
        
        try:
            print(f"Attempting password login as {INSTAGRAM_USERNAME}...")
            self.loader.login(INSTAGRAM_USERNAME, INSTAGRAM_PASSWORD)
            self.logged_in = True
            print(f"Logged in as {INSTAGRAM_USERNAME}")
            return True
        except Exception as e:
            print(f"Login failed: {e}")
            return False


    def get_shortcode_from_url(self, url):
        # Handle Post/Reel/TV
        match = re.search(r'instagram\.com\/(?:p|reel|tv)\/([A-Za-z0-9_-]+)', url)
        if match:
            return ('post', match.group(1))
            
        # Handle Stories
        # https://instagram.com/stories/username/123456789/
        match_story = re.search(r'instagram\.com\/stories\/([^\/]+)\/([0-9]+)', url)
        if match_story:
            return ('story', (match_story.group(1), match_story.group(2)))

        logging.error(f"Could not parse content from URL: {url}")
        return None

    def _export_cookies_to_netscape(self, cookie_file_path):
        """Exports instaloader cookies to a Netscape format cookies.txt for yt-dlp"""
        try:
            with open(cookie_file_path, 'w') as f:
                f.write("# Netscape HTTP Cookie File\n")
                f.write("# This file was generated by instagram_service.py\n")
                
                for cookie in self.loader.context._session.cookies:
                    # Netscape format: domain, flag, path, secure, expiration, name, value
                    domain = cookie.domain
                    flag = "TRUE" if domain.startswith('.') else "FALSE"
                    path = cookie.path
                    secure = "TRUE" if cookie.secure else "FALSE"
                    expiration = str(int(cookie.expires)) if cookie.expires else "0"
                    name = cookie.name
                    value = cookie.value
                    f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n")
            return True
        except Exception as e:
            logging.error(f"Failed to export cookies: {e}")
            return False

    def check_download_type(self, url):
        """Checks if the URL is a single video or a playlist (story feed)"""
        import yt_dlp
        
        cookie_file = "cookies.txt"
        if self.logged_in and not os.path.exists(cookie_file):
             self._export_cookies_to_netscape(cookie_file)

        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'cookiefile': cookie_file if self.logged_in and os.path.exists(cookie_file) else None,
        }
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                if 'entries' in info:
                    return {'type': 'playlist', 'count': len(info['entries']), 'info': info}
                else:
                    return {'type': 'video', 'info': info}
        except Exception as e:
            logging.error(f"yt-dlp info fetch failed: {e}")
            return {'type': 'error', 'error': str(e)}

    def download_with_ytdlp(self, url, target_dir, playlist_index=None):
        """Fallback download using yt-dlp. playlist_index is 1-based."""
        import yt_dlp
        
        logging.info(f"Attempting download with yt-dlp for {url} (Index: {playlist_index})")
        
        cookie_file = "cookies.txt"
        if self.logged_in:
            if not os.path.exists(cookie_file):
                 self._export_cookies_to_netscape(cookie_file)
        
        ydl_opts = {
            'outtmpl': os.path.join(target_dir, '%(id)s.%(ext)s'),
            'cookiefile': cookie_file if self.logged_in and os.path.exists(cookie_file) else None,
            'quiet': True,
            'no_warnings': True,
        }
        
        if playlist_index:
            ydl_opts['playlist_items'] = str(playlist_index)
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                
                # If playlist item, info might be the playlist or the item depending on extraction
                if 'entries' in info:
                     # If we downloaded specific item from playlist, extract_info might still return playlist structure?
                     # Actually with playlist_items, it typically returns the info of that item or list of items
                     pass

                # Since prompt was for generic download, we rely on file check
                files = os.listdir(target_dir)
                for f in files:
                     if f.endswith('.mp4') or f.endswith('.mkv') or f.endswith('.webm'):
                             return os.path.join(target_dir, f)
                             
        except Exception as e:
            logging.error(f"yt-dlp failure: {e}")
            return None
            
        return None

    def download_post(self, url, target_dir, playlist_index=None):
        # Trying yt-dlp first as per user request for "another tool" robustness
        # It handles both posts and stories well if cookies are correct
        
        # Ensure target dir exists
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        video_path = self.download_with_ytdlp(url, target_dir, playlist_index)
        if video_path:
            return video_path
            
        logging.info("yt-dlp failed or returned None, falling back to Instaloader logic (Only for single posts)...")

        if playlist_index:
             logging.error("Instaloader fallback does not support playlist index selection.")
             return None

        parsing_result = self.get_shortcode_from_url(url)
        if not parsing_result:
            logging.error(f"Aborting download: Invalid URL format for {url}")
            return None
            
        content_type, content_data = parsing_result

        try:
            if content_type == 'post':
                shortcode = content_data
                logging.info(f"Fetching post metadata for {shortcode}...")
                post = instaloader.Post.from_shortcode(self.loader.context, shortcode)
                
                if not post.is_video:
                    logging.warning(f"Post {shortcode} is not a video.")
                    return None

                logging.info(f"Downloading post {shortcode} to {target_dir}...")
                self.loader.download_post(post, target=target_dir)
            
            elif content_type == 'story':
                username, story_id = content_data
                logging.info(f"Fetching story {story_id} from user {username}...")
                
                # To download a story, we often need to iterate the user's stories
                # This requires login (which we have) and the target user being public or followed
                
                # Get profile ID
                profile = instaloader.Profile.from_username(self.loader.context, username)
                
                # Iterate stories
                found = False
                stories = self.loader.get_stories(userids=[profile.userid])
                
                for story in stories:
                    for item in story.get_items():
                        # The URL usually contains the media ID
                        if str(item.mediaid) == story_id:
                            found = True
                            if not item.is_video:
                                logging.warning("Story item is not a video.")
                                return None
                            
                            logging.info(f"Found story item! Downloading to {target_dir}...")
                            self.loader.download_storyitem(item, target=target_dir)
                            break
                    if found:
                        break
                
                if not found:
                    logging.error(f"Story {story_id} not found (it might be expired, skipped, or from a private account I don't follow).")
                    return None

            # Find the downloaded video file
            files = os.listdir(target_dir)
            logging.info(f"Files in {target_dir}: {files}")
            
            for filename in files:
                if filename.endswith(".mp4"):
                    return os.path.join(target_dir, filename)
            
            logging.error("Download completed but no .mp4 file found.")
            return None
            
        except instaloader.LoginRequiredException:
            logging.error("Error: Login Required. The session might be invalid or the content is private.")
        except instaloader.ConnectionException as e:
             logging.error(f"Connection Error: {e}")
        except Exception as e:
            logging.error(f"Error downloading content: {type(e).__name__}: {e}")
            
        return None



